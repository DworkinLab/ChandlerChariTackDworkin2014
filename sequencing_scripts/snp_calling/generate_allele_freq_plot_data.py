'''
Inputs a SNP call file and a pileup file generated by samtools
Outputs allele frequencies
'''

import sys

snpcall_file = sys.argv[1]
snpcall_handle = open(snpcall_file, 'r')

pileup_file = sys.argv[2]
pileup_handle = open(pileup_file, 'r')


qual_thresh = 30 #Minimum genotype quality to call a SNP genotype

#Let's go through the SNP call file and the pileup files simultaneously
#Every time we find a SNP in the SNP call file that qualifies, we will:
#	-Go to the corresponding line in the pileup file
#	-Count the number of reference and alternate alleles in each backcross line
#    (read depth of coverage, how many reference alleles, and then subtract to get number of
#     non-reference alleles)
#	-Figure out which parent strain carries the reference allele and which carries the
#	 reference allele
#	-Output: Chrom, Pos, SAM-SAMlike, SAM-ORElike, ORE-SAMlike, ORE-ORElike, Long-SAMlike, Long-ORElike, Short1-SAMlike, Short1-ORElike, etc.

for cur_line in snpcall_handle:
    #Make sure it's not a comment/header line
    if cur_line[0] != "#":
        #Get the genotypes
        cur_fields = cur_line.split("\t")
        sam_info = cur_fields[9] 
        ore_info = cur_fields[10]
        sam_geno = sam_info.split(":")[0]
        ore_geno = ore_info.split(":")[0]
        sam_qual = int(sam_info.split(":")[3])
        ore_qual = int(ore_info.split(":")[3])
        #Keep only the SNPs for which both lines are homozygous and different from each other
        # Also make sure that they are high genotype qualities
        # Also, for now, let's skip any indel alleles because their pileups are difficult to parse
        not_indel = (len(cur_fields[3]) == len(cur_fields[4]))
        if ((sam_geno != "0/1") & (ore_geno != "0/1") & (sam_geno != ore_geno) & (sam_qual >= qual_thresh) & (ore_qual >= qual_thresh) & not_indel):
            #We've found a good SNP!
            #Now read the next line in the pileup file, and repeat until we find the one that corresponds
            # to the current SNP
            pileup_line = pileup_handle.readline()
            pileup_fields = pileup_line.split("\t")
            while not ((pileup_fields[0] == cur_fields[0]) & (pileup_fields[1] == cur_fields[1])):
                pileup_line = pileup_handle.readline()
                pileup_fields = pileup_line.split("\t")
            if not ((pileup_fields[0] == cur_fields[0]) & (pileup_fields[1] == cur_fields[1])):
                #This should never be called, really, since we just exited a while loop that ends
                # only when this condition is not satisfied... but just in case
                print("ERROR: SNP call line does not match pileup line")
                quit()
            else:
                #Count the number of reference and non-reference reads for each
                ref_counts = []
                alt_counts = []
                for i in range(11):
                    coverage_col = 3 + i*3
                    total_coverage = int(pileup_fields[coverage_col])
                    #How many reference alleles were there?
                    ref_count = pileup_fields[coverage_col+1].count('.') + pileup_fields[coverage_col+1].count(',')
                    alt_count = total_coverage - ref_count
                    ref_counts.append(ref_count)
                    alt_counts.append(alt_count)
                #Now figure out whether SAM or ORE is the reference 
                if sam_geno == "0/0":
                    sam_counts = ref_counts
                    ore_counts = alt_counts
                else:
                    sam_counts = alt_counts
                    ore_counts = ref_counts
            out_line = cur_fields[0] #Chromosome
            out_line = out_line + ',' + cur_fields[1] #Position
            for i in range(11):
                out_line = out_line + ',' + str(sam_counts[i])
                out_line = out_line + ',' + str(ore_counts[i])
            print(out_line)            

pileup_handle.close()
snpcall_handle.close()
